%!PS

currentpacking true setpacking

/Inspect <<
	/refs    <<>>
	/buffer  1024 string
	/break?  true
	/indent? true
	/depth   0
	/depth++ {/depth depth 1 add def} bind
	/depth-- {/depth depth 1 sub def} bind
	/indent  {indent? {depth {(\t) print} repeat} {/indent? true def} ifelse} bind
	/priv    {0 eq {(-private-)} {( --private-- )} ifelse 8 print} bind
	/nl      {(\n) print} bind
	/saveref {dup refs exch refs length put} bind
	/p {
		(\033[38;5;) print
		buffer cvs print
		(m) print
		dup type /stringtype ne {buffer cvs} if
		print
		(\033[0m) print
	} bind
	/arraytype {
		dup refs exch known {
			(Circular Reference ) 6 p
			refs exch get
			6 p
		} {
			saveref
			break? exch
			/break? true def
			dup xcheck {({)} {([)} ifelse 8 p
			dup rcheck {
				dup length 0 gt {
					nl dup
					depth++
					{call} forall
					depth--
					indent
				} if
			} {1 priv} ifelse
			xcheck {(})} {(])} ifelse 8 p
			/break? exch def
		} ifelse
	} bind
	/booleantype {13 p} bind
	/devicetype {
		(Device ) 11 p
		/indent? false def
		dup getdeviceprops .dicttomark call
		/break? false def
	} bind
	/dicttype {
		dup refs exch known {
			(Circular Reference ) 6 p
			refs exch get
			6 p
		} {
			saveref
			break? exch
			(<<) 9 p
			dup rcheck {
				dup length 0 gt {
					dup nl
					depth++
					{
						exch
						/break? false def
						call
						/break? true def
						( => ) 8 p
						/indent? false def
						call
					} forall
					depth--
					indent
				} if pop
			} {1 priv} ifelse
			(>>) 9 p
			/break? exch def
		} ifelse
	} bind
	/filetype {
		(File ) 11 p
		dup status not {((invalid) ) 11 p} if
		mark exch {
			dup fileposition
			dup 3 -1 roll
			bytesavailable add
			exch
		} stopped {
			$error /newerror false put
			((not positionable)) 11 p
		} {
			(@ ) 11 p 11 p
			(/)  11 p 11 p
		} ifelse
		cleartomark
	} bind
	/fonttype {pop (FontID) 11 p} bind
	/gstatetype {
		(Graphics State ) 11 p
		gsave setgstate
		/indent? false def
		<<
			/LineWidth     currentlinewidth
			/LineCaps      currentlinecap  [(butt) (round) (square)] exch get
			/LineJoints    currentlinejoin [(miter) (round) (bevel)] exch get
			/MiterLimit    currentmiterlimit
			/AdjustStrokes currentstrokeadjust
			/Dashes        [currentdash]
			/Colour        [currentcolor]
			/ColourSpace   currentcolorspace
			/Greyness      currentgray
			/HSB           [currenthsbcolor]
			/RGB           [currentrgbcolor]
			/CMYK          [currentcmykcolor]
		>> call
		/break? false def
		grestore
	} bind
	/integertype {3 p} bind
	/marktype {pop (Mark) 9 p} bind
	/nametype {dup xcheck not {(/) 10 p} if 10 p} bind
	/nulltype {pop (null) 6 p} bind
	/operatortype {9 p} bind
	/packedarraytype {(#) 8 p arraytype} bind
	/realtype {3 p} bind
	/savetype {pop (VM Snapshot) 11 p} bind
	/stringtype {dup rcheck {(\() 14 p 14 p (\)) 14 p} {0 priv} ifelse} bind
	/unknowntype {(Unknown object: ) 9 p 9 p} bind
	/call {
		Inspect begin
		indent
		attr? {/.attr exch def} if
		dup type dup
		Inspect exch known {exec} {unknowntype} ifelse
		attr? {attr} if
		break? {nl} if
		depth 0 eq {reset} if
		end
	} bind
	/reset {
		/refs    <<>> def
		/break?  true def
		/indent? true def
		/depth   0    def
		/buffer  1024 string def
	} bind
	
	% Section: Object attributes (WIP)
	/.attr null def
	/attr? false def
	/attr {
		( <@ ) 8 p
		<< /_ exch >> begin clear
		/g {_ gcheck} bind def
		/x {_ gcheck} bind def
		/r {{_ rcheck} stopped {null} if} bind def
		/w {{_ wcheck} stopped {null} if} bind def
		/on  {true eq} def
		/off {true ne} def
		g {(vm:global)} {(vm:local)} ifelse 8 p
		x off r off and w off and {( access:none)            8 p} if
		x on  r on  and w on  and {( access:full)            8 p} if
		x on  r on  and w off and {( access:full,unwritable) 8 p} if
		x on  r off and w off and {( access:execute-only)    8 p} if
		x off r on  and w off and {( access:read-only)       8 p} if
		x off r off and w on  and {( access:write-only)      8 p} if
		end ( @>) 8 p
	} bind
>> def

/=== {
	dup
	Inspect begin
	call
	end
} bind def

/? {
	count array astore dup
	[exch aload pop 2 1 counttomark 2 sub {-1 roll} for]
	Inspect /call get forall aload pop
} bind def

setpacking
